# СancellationToken - почему он struct и что вообще происходит?

*Гочаров А. В.*

## Введиие.
Мне повезло, последние несколько лет (и несколько компаний) я занимаюсь разработкой высоконагруженых систем. Мне это нравиться. В тоже время, в этих компаниях, я провожу технические собеседования. Хороший кандидат, с моей точки зрения, должен отлично знать свой инструемент, и иметь фантазию для поиска решений проблем с которыми он еще не сталкивался. Собеседования начинаются, почти всегда, с классического примера кода (1) и просьбе кандидату описать все что в коде происходит и все что он вообще знает об этом. 

```csharp
[1]
  int a = 1;
  object b = a;
  long c = (long)b;
```
Большенство кандидатов, уделяют много внимания на boxing/unboxing, некоторые вспоминают что тут случиться ошибка приведения типа. Но для меня главное чтобы кандидат на это не остановился, и начал рассказывать про ссылочные и значемые типы, их отличия, по структуре, по объему памяти, по расположению, про жизннеый цикл, про GC и т.д. Почему?

Существуют две темы, в .NET, которые важны при разработке высоконагруженных систем на C#: 
1. Управление памятью.
2. Многопоточность.  

Конечно, когда речь идет о выской нагрузке, есть и другие вопросы, это и архитектура, и выбор систем хранения, и кэширование и т.д. и т.п. Но если речь только о .NET, то важны указанные выше две темы. Чтобы писать хороший, быстрый, надежный код, нужно в этом разбираться.

## Оптимизация, оптимизация и еще раз оптимизация.

Вопрос о ссылочных типах и типах значениях тесно связан с вопросом управления памятью. Поэтому хороший разработчик должен знать это "со всех сторон".

Первое что вспоминают, говорят о различиях между ref- и val-типами, это место их хранения. Ссылочные храняться, как известно, в куче. Со значемыми типами чуть сложнее. Если они являются локальными переменнами, то объекты занчимых типов хранятся на стеке. Но есть случаи когда объект занчимого типа уходит в кучу, это:
* упаковка,
* нахождение в контейнере (List, Array, и т.п.),
* когда в классе есть поле значимого типа.

Т.к. за кучу отвечает сборщик мусора, то все что попадает в кучу ведет, в конечном итоге, к запуску GC. И чем больше в кучу попадает, тем сложнее может становиться граф объектов, тем чаще и дольше работает GC. 
Другими словами, если у нас возник вопрос об оптимизации нашего кода, в отношении работы GC (*сразу отмечу, такой вопрос должен возникнуть только после серьезного профилирования, когда мы выжали все из оптимизаций другого рода (архитектуры, бд, кэширования)*), то надо внимательно смотреть на сущности которые мы используем. 


## Заключение.
