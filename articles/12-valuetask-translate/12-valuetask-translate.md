# ValueTask Что? Где? Когда?.
автор: *Stephen*  
перевод *Гончаров А.В*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/) 

В вышедшем .NET Framework 4 было впервые представлено пространство имен `System.Threading.Tasks` и в нем, класс `Task`. Этот тип, и его производный `Task<TResult>` давно стали одной из основ программирования на .NET, ключевыми аспектами асинхронной модели, реализованной в C# 5, с его ключевыми словами `async/await`. В этой статье я расскажу о новых типап `ValueTask/ValueTask<TResult>`, которые были введены с целью улучшить производительность асинхронного кода, в тех случаях, когда важно снижение накладных расходов при работе с памятью. 

## Task
Task служит нескольким целям, но основной из них это "promise" - отбъект, представляющий собой завершение какой-либо операции. Вы инициируете операцию и получаете Task, этот Task будет завершен когда завершиться операция, что может происходить синхронно, как часть инициатора операции (например доступ к некоторым данным, которые уже буферезированы), либо же асинхронно, но завершиться к тому моменту, когда вы получите Task (например быстрый доступ к данным, которые еще не были буфиризированны), или же асинхронно, после того как вы получили Task (например, при получении данных по сети). Поскольку операции могут завершаться асинхронно, вам либо надо блокировать поток в ожидании результата (что, часто, противоречить цели по которой операция выполняется асинхронно), либо же вы предоставляете метод обратного вызова, который будет выполнен по завершению асинхронной операции. Модель обратного вызова в .NET 4 была представлена явным образом посредством метода ContinueWith объекта класса Task, пренемавшего на вход делегат, который вызывался по завершению задачи.

```csharp
SomeOperationAsync().ContinueWith(task =>
{
    try
    {
        TResult result = task.Result;
        UseResult(result);
    }
    catch (Exception e)
    {
        HandleException(e);
    }
});
```
Но с версии .NET Frmaework 4.5 и C# 5, задачи стали просто ожидаться (`await`ed), упращая получения результатов асинхронных операций. А генерируемый код был способен оптимизировать все упомянутые выше операции, корректно обрабатывая завершение, не смотря на то, была ли операция завершина синхронно, асинхронно, но быстро, или же асинхронно, после (уже неявно) предоставления делегата обратного вызова.   
```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
Task как класс очень гибка и имеет ряд приемуществ. Например, вы можете ожидать ее несколько раз, любым количеством потребителей, конкурентно. В можете сохранить ее в словарь для любого числа последующих потребителей, для ожидания в будущем, что позволяет ей быть использованной как кэш для результатов, получаемых асинхронно. Вы можете блокировать поток, в ожидании завершения задачи, если того требует сценарий. И вы можете записать и ожидать завершения разнообразного набора опираций над задачами (иногда упоменаются как "комбинаторы"), таких как, например, "when any" - асинхронное ожидание завершения первой, из множеста, задач.

 Как бы там ни было, но в наиболее общем случае - простом запуске асинхронной операции и ожидания результата ее выполнения, нет необходимости во всей этой гибкости:

```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
В этом случае нам не нужно ожидать завершения несколько раз, мы не сталкиваемся с конкурентным ожиданием, не идет речи о синхронной блокировке или написании комбинаций. Нам просто нужно получить результат асинхронной операции. Это, в конце концов, так же как мы обычно пишем синхронный код (например `TResult result = SomeOperation();`), и это естественно транслируется в `async/await`.

Более того, Task имеет потенциальный недостаток, например в тех случаях когда часто создаются экземпляры этого класса, при том что высокая пропускная способности и производительность кода являются ключивыми. Task - это класс. А это значит, что каждая операция которая создает экземпляр задачи аллоцирует объект, чем больше объектов мы аллоцируем, тем больше требоуется работы со стороны GC, и тем больше тратиться ресурсов на работу сборщика мусоар, ресурсов, которые могли бы быть использованы на другие цели.

Среда выполнения и основные библиотеки смаягчают это во многих ситуациях. Например, если вы пишите метод как приведен ниже:
```csharp
public async Task WriteAsync(byte value)
{
    if (_bufferedCount == _buffer.Length)
    {
        await FlushAsync();
    }
    _buffer[_bufferedCount++] = value;
}
```
в общем случае, в буфере будет достаточно место, и операция завершиться синхронно. Если это так, то нет ничего особенного в возвращаемой задаче, т.е. нет возвращаемого значения, дургими словами, мы имеем дело с Task - эквиволентом синхронной операции с "пустым" (`void`) возвратом. Таким образом, среда выполнения просто кэширует единственную нетипизируемую задачу и использует ее каждый раз как результат для любого async Task метода, который завершается синхронно (кэшируется сингелтон представляемый статическим свойством Task.ComletedTask). Или, к примеру, если вы напишете:
```csharp
public async Task<bool> MoveNextAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
    return _bufferedCount > 0;
}
```
В общем случае мы ожидаем, что в буфере есть некоторые данные. В таком случае метод проверяет `_bufferedCount`, видит что переменная больше нуля, и возвращает `true`. Только если на момент проверки данные не были буфирезированы, требуется выполнить асинхронную операцию. Таким образом есть только два возможных логических результата (`true` и `false`), и только два возможных состояния возврата `Task<bool>`. В таком случае, среда кэширует два таких объекта, и просто возвращает закэшированный `Task<bool>` с результатом `true`, избегая аллокации. Только в случае если операция завершается асинхронно, для возврата методу приходится аллоцировать новый экземпляр Task<bool>, т.к. ему требуется вернуть объект вызывающей стороне, прежде чем будет известен результат операции, и требуется иметь уникальный объект, в который метод сохранит реузльтат, когда операция завершиться.
    
    





## ValueTask\<TResult\> and synchronous completion

## ValueTask\<TResult\> and asynchronous completion

## Non-generic ValueTask

## Implementing IValueTaskSource / IValueTaskSource\<T\>

## Valid consumption patterns for ValueTasks

## Should every new asynchronous API return ValueTask / ValueTask\<TResult\>?
  
## What’s Next for ValueTask and ValueTask\<TResult\>?

