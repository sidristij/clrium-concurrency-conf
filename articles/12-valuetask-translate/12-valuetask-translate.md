# ValueTask - почему, зачем и как?
автор: *Stephen Toub*  
перевод *Гончаров А.В*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/) 

В вышедшем .NET Framework 4 было впервые представлено пространство имен `System.Threading.Tasks` и класс `Task`. Этот тип, и его дочерний класс `Task<TResult>`, давно стали одной из основ программирования на .NET, они стали ключевыми аспектами асинхронной модели, реализованной в C# 5, с его `async/await`. В этой статье я расскажу о новых типап `ValueTask/ValueTask<TResult>`, которые были введены с целью повышения производительность асинхронного кода, в тех случаях, когда снижение накладных расходов при работе с памятью имеет значение. 

## Task
`Task` служит нескольким целям, но основной из них это "promise" - отбъект, представляющий собой завершение какой-либо операции. Вы инициируете операцию и получаете `Task`, этот `Task` будет завершен когда завершиться операция, что может происходить синхронно, как часть инициатора операции (например доступ к некоторым данным, которые уже буферезированы), либо же асинхронно, но завершиться *к тому моменту*, когда вы получите `Task` (например быстрый доступ к данным, которые еще не были буфиризированны), или же асинхронно, *после того* как вы получили `Task` (например, при получении данных по сети). Поскольку операции могут завершаться асинхронно, вам либо надо блокировать поток в ожидании результата (что, часто, противоречить цели по которой операция выполняется асинхронно), либо же вы предоставляете метод обратного вызова, который будет выполнен по завершению асинхронной операции. Модель обратного вызова в .NET 4 была представлена явным образом посредством метода ContinueWith объекта класса `Task`, пренемавшего на вход делегат, который вызывался по завершению задачи.

```csharp
SomeOperationAsync().ContinueWith(task =>
{
    try
    {
        TResult result = task.Result;
        UseResult(result);
    }
    catch (Exception e)
    {
        HandleException(e);
    }
});
```
Но с версии .NET Frmaework 4.5 и C# 5, задачи стали просто ожидаться (`await`ed), упращая получения результатов асинхронных операций. А генерируемый код был способен оптимизировать все упомянутые выше случаи, корректно обрабатывая завершение, не смотря на то, была ли операция завершина синхронно, асинхронно, но быстро, или же асинхронно, после (уже неявно) предоставления делегата обратного вызова.   
```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
`Task`, как класс, очень гибок и имеет ряд приемуществ. Например, вы можете "ожидать" объект этого класса несколько раз, любым количеством потребителей, конкурентно. В можете сохранить его в словарь для любого числа пользователей, для ожидания в будущем, что позволяет ему быть использованным как кэш для результатов, получаемых асинхронно. Вы можете блокировать поток, в ожидании завершения задачи, если того требует сценарий. Вы можете использовать комбинаторы для различных стратегий ожидания завершения наборов задач, например, "when any" - асинхронное ожидание завершения первой, из множеста, задач.

Как бы там ни было, но в наиболее общем случае - простом запуске асинхронной операции и ожидания результата ее выполнения, нет необходимости во всей этой гибкости:

```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
В этом случае нам не нужно ожидать завершения несколько раз, мы не сталкиваемся с конкурентным ожиданием, не идет речи о синхронной блокировке или написании комбинаций. Нам просто нужно получить результат асинхронной операции. Это, в конце концов, так же как мы обычно пишем синхронный код (например `TResult result = SomeOperation();`), и это естественно транслируется в `async/await`.

Более того, `Task` имеет потенциальный недостаток, например в тех случаях, когда экземпляры этого класса создаются часто, в коде где высокая пропускная способности и производительность кода являются ключивыми. `Task` - это класс, а значит, каждая операция которая создает экземпляр задачи аллоцирует объект в куче. Чем больше объектов мы создаем, тем больше требоуется работы со стороны GC, и тем больше тратиться ресурсов на сборщик мусора, ресурсов, которые могли бы быть использованы на другие цели.

Среде выполнения и основным библиотеки, во многих ситуациях, удается смаягчить это. Например, если вы пишите метод, как приведен ниже:
```csharp
public async Task WriteAsync(byte value)
{
    if (_bufferedCount == _buffer.Length)
    {
        await FlushAsync();
    }
    _buffer[_bufferedCount++] = value;
}
```
чащще всего, в буфере будет достаточно место, и операция завершиться синхронно. Если это так, то нет ничего особенного в возвращаемой задаче, т.е. нет возвращаемого значения, дургими словами, мы имеем дело с `Task` - эквиволентом синхронной операции с "пустым" (`void`) возвратом. По этой причине, среда выполнения просто кэширует единственную нетипизируемую задачу, и использует ее каждый раз как результат для любого async `Task` - метода, завершающегосяс синхронно (кэшируется синглтон, представляемый статическим свойством `Task.ComletedTask`). Или, к примеру, если вы напишете:

```csharp
public async Task<bool> MoveNextAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
    return _bufferedCount > 0;
}
```
мы ожидаем, чаще всего, что в буфере есть некоторые данные. В таком случае метод проверяет `_bufferedCount`, видит что переменная больше нуля, и возвращает `true`. Только если на момент проверки данные не были буфирезированы, требуется выполнить асинхронную операцию. Таким образом есть только два возможных логических результата (`true` и `false`), и только два возможных состояния возврата `Task<bool>`. В таком случае, среда кэширует два таких объекта, и просто возвращает закэшированный `Task<bool>` с результатом `true`, избегая аллокации. Только в случае если операция завершается асинхронно уже после "возврата", то методу приходится аллоцировать новый экземпляр Task<bool>, т.к. ему требуется вернуть объект вызывающей стороне, прежде чем будет известен результат операции, и этот объект должен быть уникальным, в который метод сохранит реузльтат, когда операция завершиться.
    
    
Среда выполнения делает такого рода кэширования и в других случаях, но не возможно так делать везде. Например, метод:
```csharp
public async Task<int> ReadNextByteAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
 
    if (_bufferedCount == 0)
    {
        return -1;
    }
 
    _bufferedCount--;
    return _buffer[_position++];
}
```
так же, часто завершается синхронно. Но, в отличее от предыдущего примера, этот метод возвращает целочисленный результат, который имеет примерно четыре миллиарда возможных значений, и для кэширования `Task<int>`, в этой ситуации, потребовало бы, потенциально, гигабайтов памяти. Среда поддерживает небольшой кэш для `Task<int>`, только для нескольких небольших значений. Так, например, если операция завершится синхронно (данные присутствуют в буфере), со значением 4, это приведет к использованию кэша, но если результатом будет синхронное завершение со значением 42, это приведет к созданию нового экземпляра `Task<int>`, аналогично вызову `Task.FromResult(42)`.

Многие реализации библиотеки пытаются смягчить такие ситуации посредством поддержки своих собственных кэшей. К примеру, перегрузка `MemoryStream.ReadAsync`, введенная в .NET Framework 4.5, всегда завершается синхронно, т.к. это всего лишь чтение из памяти. `ReadAsync` возвращает `Task<int>`, где целочисленный результат представляет число прочитанных байтов. Этот метод не редко используется в цикле, при этом, часто, количество запрашиваемых байтов не меняется от итерации к итерации. В таких случаях, `ReadAsync` часто может прочитать запрошенное количество байт. Таким образом, для повторяющихся вызовов `ReadAsync` выполняется синхронно и возвращает объект `Task<int>`, с тем же результатом что и на предыдущей итерации. По этой причине, `MemoryStream` кэширует крайнюю успешно выполненнную задачу, и для всех последующих вызовов, если новый результат совпадает с тем что был закэширован, возвращается `Task<int>` из кэша. Если же результат не совпадает, то используется `Task.FromResult` для создания нового экземпляра, этот экземпляр сохраняется в кэше и возвращается вызывающей стороне.

Не смотря на это, существует много случаев, когда операция завершается синхронно, и при этом вынуждена создавать и возвращать новый экземпляр `Task<TResult>`.


## ValueTask\<TResult\> и синхронное завершение.

Все это послужило мотивацией для введения в .NET Core 2.0 нового типа `ValueTask<TResult>`. Так же, этот тип сделали доступным в других  релизах .NET через nuget-пакет `System.Threading.Tasks.Extensions`.

`ValueTask<TResult>` был введен в .NET Core 2.0 как структура, способная оборачивать `TResult` или `Task<TResult>`. Это знчаит, что объекты этого типа могут быть возвращены из async-метода, и если метод завершился успешно и синхронно, нам нет необходимости создавать что-либо в куче, мы просто инициализируем экземпляр `ValueTask<TResult>` со значением результата, и возвращаем его. Только если метод завершается асинхронно, нам необходимо создать `Task<TResult>`. В этом случаае `ValueTask<TResult>` создается как обертка над `Task<TResult>`. Это сделано для минимизации структуры `ValueTask<TResult>`. Т.к. и в случае успеха, и в случае неудачи, асинхронный метод возвращает `Task<TResult>`, то, чтобы не хранить дополнительные поля (например для хранения исключения) на оба случая в экземплярах `ValueTask<TResult>`, он просто агригирует возвращаемый `Task<TResult>`.

Учитывае вышеизложенное, например в методе `MemoryStream.ReadAsync`, и подобных ему, больше нет необходимости заниматься кэшированием, вместо этого его можно реализовывать следующим образом:
```csharp
public override ValueTask<int> ReadAsync(byte[] buffer, int offset, int count)
{
    try
    {
        int bytesRead = Read(buffer, offset, count);
        return new ValueTask<int>(bytesRead);
    }
    catch (Exception e)
    {
        return new ValueTask<int>(Task.FromException<int>(e));
    }
}
```

## ValueTask\<TResult\> и асинхронное завершение.

Иметь возможность писать асинхронные методы, которые не требуют дополнительных аллокаций памяти для результата, при синхронном завершении, это большой успех. Именно для этого `ValueTask<TResult>` был добавлен в .NET Core 2.0, и все новые методы, которые, как ожидается, будут использоваться на "горячих путях", теперь в качестве типа возвращаемого занчения вместо `Task<TResult>` используют `ValueTask<TResult>`. К примеру, новая перегрузка метода `ReadAsync` для `Stream`, в .NET Core 2.1 (принимающая в качестве параметра `Memory<byte>` вместо `byte[]`), возвращает экземпляр `ValueTask<int>`. Что позволило значительно снизить колличество аллокаций при работе с потоками (очень часто метод `ReadAsync` заверщается синхронно, как и в примере с `MemoryStream`). 

Однако, и при разработке сервисов с высокой пропускной способностью, нам нужно всеми силами стараться избегать дополнительных аллокаций. Это значит что необходимо задуматься о снижении числа операций выделения памяти в куче связанных с асинхронным завершением операций.

В модели async/await, для любой операции, которая заканчивается асинхронно, нам нужна возможность вернуть объект для ожидание завершения - клиент должен иметь возможность передать делегат обратного вызова, который будет выполнен по заверешнию операции. Это требует наличия уникального объекта в куче, который будет служить как канал выполнения обратного вызова. Отметим, однако, данная конструкция ни чего не говорит о том, можно ли повторно использовать возвращенный объект ожидания, уже после завершения асинхронной операции. Если объект может быть переиспользован, то API может поддерживать пул для такого рода объектов. Но в таком случае этот пул не может подерживать конкурентный доступ.

Для поддержки возможности работы с такого рода пулами, в .NET Core 2.1 был добавлен интерфейс `IValueTaskSource<TResult>`, а стурктура `ValueTask<TResult>` была расширена, для возможности агригации не только объектов типа `TResult` или `Task<TResult>`, но и экземпляры `IValueTaskSource<TResult>`. Этот интерфейс обеспечивает базовый функционал, необходимый для представления асинхронных операций через `ValueTask<TResult>`, в той же манери что и через `Task<TResult>`:
```csharp
public interface IValueTaskSource<out TResult>
{
    ValueTaskSourceStatus GetStatus(short token);
    void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    TResult GetResult(short token);
}
```
`GetStatus` предназначен для свойств типа `ValueTask<TResult>.IsCompleted` - позволяет узнать завершилась ли операция, и если да, то успешно или нет. `OnCompleted` используется в `ValueTask<TResult>` для запуска обратного вызова, по завершению асинхронной операции. `GetResult` используется для получения результата, или для распространения возникшего исключения.

У большенства разработчиков вряд ли когда либо возникнет необходимость иметь дело с интерфейсом `IValueTaskSource<TResult>`, т.к. асинхронные методы возвращают оборачивающий его `ValueTask<TResult>`. Сам интерфейс в первую очередь предназначен для тех программистов, которые разрабатывают высоко-производительные API, стремящихеся избежать излишней работы с кучей. 

В .NET Core 2.1 можно выделить несколько такого рода API. Наиболее известный это новые перегрузки методов `Socket.ReceiveAsync` и `Socket.SendAsync`. К примеру:
```csharp	
public ValueTask<int> ReceiveAsync(Memory<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);
```
В качестве возвращаемого значения, используются объекты типа `ValueTask<int>`.
Если метод завершается синхронно, то он возвращает `ValueTask<int>` с соответствующим значением: 

```csharp
int result = …;
return new ValueTask<int>(result);
```

Если же операция завершается асинхронно, то использется кэшируемый объект, реализующий интерфейс `IValueTaskSource<TResult>`:
```csharp
IValueTaskSource<int> vts = …;
return new ValueTask<int>(vts);
```
Реализация `Socket` поддерживает один кэшируемый объект для получения, и один для отправления данных, до тех пор, пока каждый используется один за раз. Это снижает количество дополнительного выделения памяти, даже в случае асинхронного выполнения.
Например, в .NET Core 2.1, `NetworkStream` перегружает метод `ReadAsync` класса `Stream`:
```csharp
public virtual ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken);
```
Перегрузка этого метода в `NetworkStream` просто делегирует работу метроду `Socket.ReceiveAsync`, а значит повышение эффективности, в плане работы спамятью, метода сокета, повышиет эффективность и метода `NetworkStream`.


## Non-generic ValueTask
Целью введения `ValueTask<T>` в .NET Core 2.0 была только оптимизация случаев синхронного завершения - чтобы избежать создания `Task<TResult>` для сохранения уже полученного результата `TResult`. Это так же значит, что не было необходимости в нетипизируемом  `ValueTask`: в случаях синхронного завершения методы используют синглтон через свойство `Task.CompletedTask`, это же, неявным образом, делает среда выполнения для `async Task`-методов.

Но, с появлением возможности избегать лишних аллокаций и при асинхронном выполнении, необходимость в нетипизированном `ValueTask` сново стала актуальна. По этой причине, в .NET Core 2.1 мы ввели нетипизируемые `ValueTask` и `IValueTaskSource`.  Они являются аналогами соответствующих обобщенных типов, и используются тем же образом, но для методов не возвращающих значения.


## Реалзиация IValueTaskSource / IValueTaskSource\<T\>

У большенства разработчиков не возникнит необходимости реализовывать эти интерфейсы. Кроме того, их реализация это не простая задача. Если же вы решите что вам необходима реализовать их самостоятельно, то существует несколько реализаций внутри .NET Core 2.1, которые могут послужить в качестве примеров:
* [AwaitableSocketAsyncEventArgs](https://github.com/dotnet/corefx/blob/61f51e6b2b26271de205eb8a14236afef482971b/src/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs#L808)  
* [AsyncOperation\<TResult\>](https://github.com/dotnet/corefx/blob/89ab1e83a7e00d869e1580151e24f01226acaf3f/src/System.Threading.Channels/src/System/Threading/Channels/AsyncOperation.cs#L37)  
* [DefaultPipeReader](https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/System.IO.Pipelines/src/System/IO/Pipelines/Pipe.DefaultPipeReader.cs#L16)  

Для упращения это задачи, для разработчков которые захотят сделать свои реализации, мы планируем представить в .NET Core 3.0 тип `ManualResetValueTaskSourceCore<TResult>`. Эта структура будет реализовывать всю необходимую логику. Экземпляр `ManualResetValueTaskSourceCore<TResult>`, можно будет инкапсулировать в другом объекте, реализующем `IValueTaskSource<TResult>` и / или `IValueTaskSource`, и делегировать ему большую часть работы. Вы можете больше узнать об этом в связанном issue в репозитории dotnet/corefx по ссылке ttps://github.com/dotnet/corefx/issues/32664.
  
## Правильная модель использования ValueTasks
При поверхностном рассмотрении видно что `ValueTask` and `ValueTask<TResult>` более ограниченны чем `Task` и `Task<TResult>`. И это нормально, даже желательно, ведь их основная цель - это ожитдать завершения асинхронного выполнения.

Все же, т.к. `ValueTask` and `ValueTask<TResult>` могут агрегировать переиспользуемые обхекты, существуют значительные ограничения в их использовании, по сравнению с `Task` and `Task<TResult>`. В общем, следующие операции **НИКОГДА* не должны выполняться при использовании `ValueTask` / `ValueTask<TResult>`:

* **Многократное ожидание `ValueTask` / `ValueTask<TResult>`**. Экземпляры `Task` и `Task<TResult>` никогда не возвращаются из "завершенного" состояния в "незавершенное", их мы можем использовать для ожидания результата столько раз сколько захотим, и после завершения всегда получать один и тот же результат. Напротив, так как `ValueTask` / `ValueTask<TResult>`, могут выступать обертками над переиспользуемыми объектами, то их состояние, как и состояние агригируемых переиспользуемых объектов, может изменяться, переходить от "завершенного" в "незавершонное" и обратно. 

* **Конкурентно ожидать `ValueTask` / `ValueTask\<TResult\>`**. Обернутый объект ожидает работать только с одним обратным вызововм, от единственного потребителя за раз, и попытка конкурентного ожидания может легко привести к состоянию гонки и "тонким" програмным ошибкам. Конкурентное ожидания, это один из вариантов, описанного вышел **многократного ожидания**. Отметим, что `Task` / `Task<TResult>` допускают любое число конкурентных ожиданий.

* **Использование `.GetAwaiter().GetResult()` до завершения операции**. Реализации `IValueTaskSource` / `IValueTaskSource<TResult>` не должны поддерживать блокировку до завершения операци. Блокировка, по сути, приводит к состоянию гонки, и вряд ли это будет ожидаемое, со стороны потребителя, поведение. В то время как `Task` / `Task<TResult>` позволяют сделать это, тем самым заблокировать вызывающий поток до завершения операции.

Если у вас есть экземпляры `ValueTask` / `ValueTask<TResult>`, и вам требуется сделать одну из вышеописанных операций, вы должны использовать метод `.AsTask()`, посредством его вызова получить экземпляр `Task` / `Task<TResult>`, и уже с ним выполнить нужную операцию. После вызова `.AsTask()`, вы больше не должны использовать исходные `ValueTask` / `ValueTask<TResult>`.

**Корокое правило гласит**: При работе с экземпляром `ValueTask` / `ValueTask<TResult>` вы должны либо ожидать (`await`) его напрямую (или, если нужно с `.ConfigureAwait(false)`) или вызвать  `.AsTask()`, и больше никогда не использовать исходын объект `ValueTask` / `ValueTask<TResult>`.

```csharp
// Given this ValueTask<int>-returning method…
public ValueTask<int> SomeValueTaskReturningMethodAsync();
…
// GOOD
int result = await SomeValueTaskReturningMethodAsync();
 
// GOOD
int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false);
 
// GOOD
Task<int> t = SomeValueTaskReturningMethodAsync().AsTask();
 
// WARNING
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
... // storing the instance into a local makes it much more likely it'll be misused,
    // but it could still be ok
 
// BAD: awaits multiple times
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
int result = await vt;
int result2 = await vt;
 
// BAD: awaits concurrently (and, by definition then, multiple times)
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
Task.Run(async () => await vt);
Task.Run(async () => await vt);
 
// BAD: uses GetAwaiter().GetResult() when it's not known to be done
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
int result = vt.GetAwaiter().GetResult();
```

Есть еще один дополнительный, "продвинутый", шаблон использования, который некоторые программисты могут решиться применить, надеюсь только после аккуратных измерений, с обоснованием значимой пользы от применения этого шаблона.

Объекты типов `ValueTask` / `ValueTask<TResult>` имеют некоторые свойства, которые позволяют узнать о текущем состоянии операции. К примеру, свойство `IsCompleted` вернет `true`, если операция завершена (успешно или с исключением, не важно), в противном случае - `false`, а `IsCompletedSuccessfully` вернет `true` только в случае, если операция завершилась успешно. Для самых "горячих" путей исполнения, где разработчик хочет, например, избежать дополнительных накладных расходов, которые неустранимы только при асинхронном выполнении, можно использовать вышеуказанные свойства. Так мы можем проверить состояние выполнения и решить надо ли использовать `await` / `.AsTask()` или же можно вызывать `.Result` напрямую. К примеру, реализация класса `SocketsHttpHandler` в .NET Core 2.1, имеет дело с методом `.ReadAsync` соединения, который возвращает `ValueTask<int>`. Если операция завершается синхронно, нам более не надо волноваться о возможности её отмены. Но если операция будет выполняться асинхронно, то мы хотим иметь возможность обработать запрос отмены т.к. он разорвет соединение. Т.к. это высоконагруженныая часть кода, и профилирование показало небольшое различие, код, по существу, был структурирован следующим обрзаом:
```csharp
int bytesRead;
{
    ValueTask<int> readTask = _connection.ReadAsync(buffer);
    if (readTask.IsCompletedSuccessfully)
    {
        bytesRead = readTask.Result;
    }
    else
    {
        using (_connection.RegisterCancellation())
        {
            bytesRead = await readTask;
        }
    }
}
```
Здесь вышеописаный шаблон применим, т.к. `ValueTask<int>`, ни в случае вызова `.Result`, ни в случае `await`, ни где после не используется.

## Должны ли все новые асинхронные API возвращать ValueTask / ValueTask\<TResult\>?

Если коротко, то нет. Выбор по умолчанию остается за `Task` / `ValueTask<TResult>`.

Как было показано ранее, объекты типов `Task` / `Task<TResult>` проще в плане корректного использования. По этой причине, пока  выйгрышь в производительности не превысит "выйгрыша" в удобстве/простоте использования, рекомендуется отдавать предпочтитение `Task` / `Task<TResult>`. Есть так же незначительные расходы связанные с использованием `ValueTask<TResult>` вместо `Task<TResult>`: например, при микропрофилировании видно, что `await` работает немного быстрее с `Task<TResult>` чем с `ValueTask<TResult>`. Таким образом, если вы можете использовать кэширование задач (например ваш API возвращает `Task` или `Task<bool>`), то, с точки зрения производительности, лучше использовать `Task`(`Task<bool>`). Кроме того, `ValueTask` / `ValueTask<TResult>` занимают несколько машинных слов. Это значит, что при вызове async-метода, в создаваемом при этом экземпляре коленчного автомата, появляются дополнительные поля для хранения объектов `ValueTask` / `ValueTask<TResult>`, что слегка увеличивает общий размер занемаемой памяти объектом конечного автомата.

Как бы там ни было, `ValueTask` / `ValueTask<TResult>` это отличный выбор, если:  
a) вы ожидаете что клиент вашего API будет выполнять ожидание напрямую,  
b) вашему API важно избегать дополнительных операций выделения памяти в куче, и  
c) вы ожидаете что, либо операции будут часто завершатиься синхронно, либо же у вас есть возможность эффективно использовать пулы, на случай асинхронного выполнения.

При добавления квалификаторов `abstract` / `virtual` к методу, или при определении интерфейсов, нужно задуматься, будут ли описанные выше соображения, справедливы для реализаций / переопределений метода?


  
## Что дальше?

В базовых библиотеках .NET, мы продолжим встречать новые API, возвращающие `Task` / `Task<TResult>`. Но, так же, мы увидем и новые API c `ValueTask` / `ValueTask<TResult>`, там где это будет уместно. Одним из ключивых примеров последнего является новый интерфейс `IAsyncEnumerator<T>`, поддержку которого планируется начать с .NET Core 3.0. Интерфейс `IEnumerator<T>` представляет метод `MoveNext`, который возвращает булево значение. Асинхронный аналог - `IAsyncEnumerator<T>` предоставляет метод `MoveNextAsync`. Когда мы начали проектировать эту фичу, мы думали использовать в качестве возвращаемого типа `Task<bool>`, который может быть очень эффективен при использовании кэша, в тех случаях когда операция завершается синхронно. Все же, учитывая как сильно будут распространены асинхронные перечисления, учитывая что они будут основаны на интерфейсах, у которых будет множество реализаций (некоторые из которых могут быть сильно обеспокоены вопросом производительности и аллокаций), а так же, учитывая тот факт, что большенство потребителей будут использовать эти перечисления через `await foreach`-синтаксис, мы выбрали, в качестве возвращаемого значения метода `MoveNextAsync`, тип `ValueTask<bool>`. Это позволяет остаться столь же быстрым при синхронном завершении, и, при этом, позволяет оптимизировать реализации с  "переиспользуемыми" объектами, понижая количество аллокаций на куче и для асинхронных вызовов. Фактически, компилятор C# пользуется этим при реализации асинхронных итераторов, чтобы сделать их максимально эффективными с точки зрения работы с памятью.

![Stephen Toub](https://secure.gravatar.com/avatar/2f85938ff9d752d14977fa35c0af37e5?s=96&d=mm&r=g)
**[Stephen Toub](https://devblogs.microsoft.com/dotnet/author/toub/)**  
Software Engineer, .NET


