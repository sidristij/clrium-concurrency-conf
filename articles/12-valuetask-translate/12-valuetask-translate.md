# ValueTask Что? Где? Когда?.
автор: *Stephen*  
перевод *Гончаров А.В*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/) 

В вышедшем .NET Framework 4 было впервые представлено пространство имен `System.Threading.Tasks` и в нем, класс `Task`. Этот тип, и его производный `Task<TResult>` давно стали одной из основ программирования на .NET, ключевыми аспектами асинхронной модели, реализованной в C# 5, с его ключевыми словами `async/await`. В этой статье я расскажу о новых типап `ValueTask/ValueTask<TResult>`, которые были введены с целью улучшить производительность асинхронного кода, в тех случаях, когда важно снижение накладных расходов при работе с памятью. 

## Task
Task служит нескольким целям, но основной из них это "promise" - отбъект, представляющий собой завершение какой-либо операции. Вы инициируете операцию и получаете Task, этот Task будет завершен когда завершиться операция, что может происходить синхронно, как часть инициатора операции (например доступ к некоторым данным, которые уже буферезированы), либо же асинхронно, но завершиться к тому моменту, когда вы получите Task (например быстрый доступ к данным, которые еще не были буфиризированны), или же асинхронно, после того как вы получили Task (например, при получении данных по сети). Поскольку операции могут завершаться асинхронно, вам либо надо блокировать поток в ожидании результата (что, часто, противоречить цели по которой операция выполняется асинхронно), либо же вы предоставляете метод обратного вызова, который будет выполнен по завершению асинхронной операции. Модель обратного вызова в .NET 4 была представлена явным образом посредством метода ContinueWith объекта класса Task, пренемавшего на вход делегат, который вызывался по завершению задачи.

```csharp
SomeOperationAsync().ContinueWith(task =>
{
    try
    {
        TResult result = task.Result;
        UseResult(result);
    }
    catch (Exception e)
    {
        HandleException(e);
    }
});
```
Но с версии .NET Frmaework 4.5 и C# 5, задачи стали просто ожидаться (`await`ed), упращая получения результатов асинхронных операций. А генерируемый код был способен оптимизировать все упомянутые выше операции, корректно обрабатывая завершение, не смотря на то, была ли операция завершина синхронно, асинхронно, но быстро, или же асинхронно, после (уже неявно) предоставления делегата обратного вызова.   
```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
Task как класс очень гибка и имеет ряд приемуществ. Например, вы можете ожидать ее несколько раз, любым количеством потребителей, конкурентно. В можете сохранить ее в словарь для любого числа последующих потребителей, для ожидания в будущем, что позволяет ей быть использованной как кэш для результатов, получаемых асинхронно. Вы можете блокировать поток, в ожидании завершения задачи, если того требует сценарий. И вы можете записать и ожидать завершения разнообразного набора опираций над задачами (иногда упоменаются как "комбинаторы"), таких как, например, "when any" - асинхронное ожидание завершения первой, из множеста, задач.

 Как бы там ни было, но в наиболее общем случае - простом запуске асинхронной операции и ожидания результата ее выполнения, нет необходимости во всей этой гибкости:

```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
В этом случае нам не нужно ожидать завершения несколько раз, мы не сталкиваемся с конкурентным ожиданием, не идет речи о синхронной блокировке или написании комбинаций. Нам просто нужно получить результат асинхронной операции. Это, в конце концов, так же как мы обычно пишем синхронный код (например `TResult result = SomeOperation();`), и это естественно транслируется в `async/await`.

Более того, Task имеет потенциальный недостаток, например в тех случаях когда часто создаются экземпляры этого класса, при том что высокая пропускная способности и производительность кода являются ключивыми. Task - это класс. А это значит, что каждая операция которая создает экземпляр задачи аллоцирует объект, чем больше объектов мы аллоцируем, тем больше требоуется работы со стороны GC, и тем больше тратиться ресурсов на работу сборщика мусоар, ресурсов, которые могли бы быть использованы на другие цели.

Среда выполнения и основные библиотеки смаягчают это во многих ситуациях. Например, если вы пишите метод как приведен ниже:
```csharp
public async Task WriteAsync(byte value)
{
    if (_bufferedCount == _buffer.Length)
    {
        await FlushAsync();
    }
    _buffer[_bufferedCount++] = value;
}
```
в общем случае, в буфере будет достаточно место, и операция завершиться синхронно. Если это так, то нет ничего особенного в возвращаемой задаче, т.е. нет возвращаемого значения, дургими словами, мы имеем дело с Task - эквиволентом синхронной операции с "пустым" (`void`) возвратом. Таким образом, среда выполнения просто кэширует единственную нетипизируемую задачу и использует ее каждый раз как результат для любого async Task метода, который завершается синхронно (кэшируется сингелтон представляемый статическим свойством Task.ComletedTask). Или, к примеру, если вы напишете:
```csharp
public async Task<bool> MoveNextAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
    return _bufferedCount > 0;
}
```
В общем случае мы ожидаем, что в буфере есть некоторые данные. В таком случае метод проверяет `_bufferedCount`, видит что переменная больше нуля, и возвращает `true`. Только если на момент проверки данные не были буфирезированы, требуется выполнить асинхронную операцию. Таким образом есть только два возможных логических результата (`true` и `false`), и только два возможных состояния возврата `Task<bool>`. В таком случае, среда кэширует два таких объекта, и просто возвращает закэшированный `Task<bool>` с результатом `true`, избегая аллокации. Только в случае если операция завершается асинхронно, для возврата методу приходится аллоцировать новый экземпляр Task<bool>, т.к. ему требуется вернуть объект вызывающей стороне, прежде чем будет известен результат операции, и требуется иметь уникальный объект, в который метод сохранит реузльтат, когда операция завершиться.
    
    
Среда выполнения делает такого рода кэширования и в других случаях, но не возможно так делать везде. Например, методе:
```csharp
public async Task<int> ReadNextByteAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
 
    if (_bufferedCount == 0)
    {
        return -1;
    }
 
    _bufferedCount--;
    return _buffer[_position++];
}
```
так же, часто завершается синхронно. Но, в отличее от предыдущего примера, этот метод возвращает целочисленный результат, который имеет примерно четыре миллиарда возможных значений, и кэширование `Task<int>` в этой ситуации потребовало бы, потенциально, гигабайтов памяти. Среда поддерживает небольшой кэш для `Task<int>`, но только для нескольких небольших значений. Так, например, если операция завершится синхронно (данные присутствуют в буфере), со значением как 4, это приведет к использованию кэша, но если результатом будет синхронное завершение со значением 42, это приведет к созданию нового экземпляра `Task<int>`, аналогично вызову `Task.FromResult(42)`.

Многие реализации библиотеки пытаются смягчить такие ситуации посредством поддержки своих собственных кэшей. К примеру, перегрузка `MemoryStream.ReadAsync`, введенная в .NET Framework 4.5, всегда завершается синхронно, т.к. это всего лишь чтение из памяти. `ReadAsync ` возвращает `Task<int>`, где целочисленный результат представляет число прочитанных байтов. `ReadAsync` не редко используется в цикле, при этом количество запрашиваемых байтов не меняется от итерации к итерации, в таких случаях, довольно часто `ReadAsync` может прочитать запрошенное количество байт. Таким образом, для повторяющихся вызовов `ReadAsync` выполняется синхронно и возвращает объект `Task<int>`  с тем же результатом что и на предыдущей итерации. По этой причине, `MemoryStream` кэширует крайнюю успешно выполненнную задачу. Зате, для всех последующих вызовов, если новый результат совпадает с тем что был закэширован, возвращается `Task<int>` из кэша. Если же результат не совпадает, то используется `Task.FromResult` для создания нового экземпляра, этот экземпляр сохраняется в кэше и возвращается вызывающей стороне.

Не смотря на это, существует много случаев, когда операция завершается синхронно, и при этом вынуждена аллоцировать и возвращать новый экземпляр `Task<TResult>`.


## ValueTask\<TResult\> and synchronous completion

Все это послужило мотивацией для введения в .NET Core 2.0 нового типа `ValueTask<TResult>`. Так же, этот тип сделали доступным в других  релизах .NET через nuget-пакет `System.Threading.Tasks.Extensions`.

`ValueTask<TResult>` был введен в .NET Core 2.0 как структура, способная оборачивать `TResult` или `Task<TResult>`. Это знчаит что объекты этого типа могут быть возвращены из async-метода, и если метод завершился успешно и синхронно, нам нет необходимости создавать что-либо в куче, мы просто инициализируем экземпляр `ValueTask<TResult>` со значением результата, и возвращаем его. Только если метод завершается асинхронно, нам необходимо создать `Task<TResult>`. В этом случаае `ValueTask<TResult>` создается как обертка над `Task<TResult>`. Это сделано для минимизации структуры `ValueTask<TResult>`, т.к. и в случае успеха, и в случае неудачи, асинхронный метод возвращает `Task<TResult>`, то чтобы не хранить дополнительные поля (например для хранения исключения) на оба случая в экземплярах `ValueTask<TResult>`, он просто агригирует возвращаемый `Task<TResult>`.

Учитывае вышеизложенное, например в методе `MemoryStream.ReadAsync`, и подобных ему, больше нет необходимости заниматься кэшированием, вместо этого его можно реализовывать следующим образом:
```csharp
public override ValueTask<int> ReadAsync(byte[] buffer, int offset, int count)
{
    try
    {
        int bytesRead = Read(buffer, offset, count);
        return new ValueTask<int>(bytesRead);
    }
    catch (Exception e)
    {
        return new ValueTask<int>(Task.FromException<int>(e));
    }
}
```

## ValueTask\<TResult\> and asynchronous completion
Иметь возможность писать асинхронные методы, при синхронном завершении, не требуют дополнительных аллокаций памяти для результата, это большой успех. Именно для этого `ValueTask<TResult>` был добавлен в .NET Core 2.0, и все новые методы, которые, как ожидается, будут использоваться на "горячих путях", теперь в качестве возвращаемого занчения указывают тип `ValueTask<TResult>` вместо  `Task<TResult>`. К примеру, новая перегрузка метода `ReadAsync` для `Stream`, в .NET Core 2.1 (принимающая в качестве параметра `Memory<byte>` вместо `byte[]`), возвращает экземпляр `ValueTask<int>`. Что позволило значительно снизить колличество аллокаций при работе с потоками (очень часто метод `ReadAsync` заверщается синхронно, как и в примере с `MemoryStream`). 

Однако, при разработке сервисов с высокой пропускной способностью, нам тоже нужно всеми силами стараться избегать дополнительных аллокаций. Это значит что необходимо задуматься о снижении числа аллокаций связанных с асинхронным завершением операций.

В модели async/await, для людой операции которая заканчивается асинхронно, нам нужна возможность вернуть объект для ожидание завершение операции - клиент должен иметь возможность передать делегат обратного вызова, который будет выполнен по заверешнию операции, что требует наличия уникального объекта в куче, который будет служить как калан выполнения обратного вызова. Отметим, однако, ни чего не говорит о том, можно ли повторно переиспользовать возвращенный объект ожидания, после завершения асинхронной операции. Если объект может быть переиспользован, то API может поддерживать кэш для такого рода объектов. Но в таком случае этот пул не может подерживать конкурентный доступ.

Для поддержки возможности работы с такого рода пулами, в .NET Core 2.1 был добавлен интерфейс `IValueTaskSource<TResult>`, а стурктура `ValueTask<TResult>` был расширена, для возможности агригации не только, помимо `TResult` и `Task<TResult>`, но и экземпляров `IValueTaskSource<TResult>`. Этот интерфейс обеспечивает базовую поддержку, необходимую для представления асинхронных операций через `ValueTask<TResult>`, в той же манери что и через `Task<TResult>`:
```csharp
public interface IValueTaskSource<out TResult>
{
    ValueTaskSourceStatus GetStatus(short token);
    void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    TResult GetResult(short token);
}
```
`GetStatus` предназначен для поддержки свойств типа `ValueTask<TResult>.IsCompleted`, позволяет узнать завершилась ли операция, и если да, то успешно или нет. `OnCompleted` используется в `ValueTask<TResult>` для запуска обратного вызова, по завершению асинхронной операции. `GetResult` используется для получения результата операции, или для распространения возникшего, в асинхронной операции, исключения.

У большенства разработчиков вряд ли когда либо возникнет необходимость иметь дело с интерфейсом `IValueTaskSource<TResult>`, т.к. асинхронные методы возвращают `ValueTask<TResult>`.


## Non-generic ValueTask

## Implementing IValueTaskSource / IValueTaskSource\<T\>

## Valid consumption patterns for ValueTasks

## Should every new asynchronous API return ValueTask / ValueTask\<TResult\>?
  
## What’s Next for ValueTask and ValueTask\<TResult\>?

