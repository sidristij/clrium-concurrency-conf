# ValueTask Что? Где? Когда?.
автор: *Stephen*  
перевод *Гончаров А.В*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/) 

В вышедшем .NET Framework 4 было впервые представлено пространство имен `System.Threading.Tasks` и в нем, класс `Task`. Этот тип, и его производный `Task<TResult>` давно стали одной из основ программирования на .NET, ключевыми аспектами асинхронной модели, реализованной в C# 5, с его ключевыми словами `async/await`. В этой статье я расскажу о новых типап `ValueTask/ValueTask<TResult>`, которые были введены с целью улучшить производительность асинхронного кода, в тех случаях, когда важно снижение накладных расходов при работе с памятью. 

## Task
Task служит нескольким целям, но основной из них это "promise" - отбъект, представляющий собой завершение какой-либо операции. Вы инициируете операцию и получаете Task, этот Task будет завершен когда завершиться операция, что может происходить синхронно, как часть инициатора операции (например доступ к некоторым данным, которые уже буферезированы), либо же асинхронно, но завершиться к тому моменту, когда вы получите Task (например быстрый доступ к данным, которые еще не были буфиризированны), или же асинхронно, после того как вы получили Task (например, при получении данных по сети). Поскольку операции могут завершаться асинхронно, вам либо надо блокировать поток в ожидании результата (что, часто, противоречить цели по которой операция выполняется асинхронно), либо же вы предоставляете метод обратного вызова, который будет выполнен по завершению асинхронной операции. Модель обратного вызова в .NET 4 была представлена явным образом посредством метода ContinueWith объекта класса Task, пренемавшего на вход делегат, который вызывался по завершению задачи.

```csharp
SomeOperationAsync().ContinueWith(task =>
{
    try
    {
        TResult result = task.Result;
        UseResult(result);
    }
    catch (Exception e)
    {
        HandleException(e);
    }
});
```
Но с версии .NET Frmaework 4.5 и C# 5, задачи стали просто ожидаться (`await`ed), упращая получения результатов асинхронных операций. А генерируемый код был способен оптимизировать все упомянутые выше операции, корректно обрабатывая завершение, не смотря на то, была ли операция завершина синхронно, асинхронно, но быстро, или же асинхронно, после (уже неявно) предоставления делегата обратного вызова.   
```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
Task как класс очень гибка и имеет ряд приемуществ. Например, вы можете ожидать ее несколько раз, любым количеством потребителей, конкурентно. В можете сохранить ее в словарь для любого числа последующих потребителей, для ожидания в будущем, что позволяет ей быть использованной как кэш для результатов, получаемых асинхронно. Вы можете блокировать поток, в ожидании завершения задачи, если того требует сценарий. И вы можете записать и ожидать завершения разнообразного набора опираций над задачами (иногда упоменаются как "комбинаторы"), таких как, например, "when any" - асинхронное ожидание завершения первой, из множеста, задач.

 Как бы там ни было, но в наиболее общем случае - простом запуске асинхронной операции и ожидания результата ее выполнения, нет необходимости во всей этой гибкости:

```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```
В этом случае нам не нужно ожидать завершения несколько раз, мы не сталкиваемся с конкурентным ожиданием, не идет речи о синхронной блокировке или написании комбинаций. Нам просто нужно получить результат асинхронной операции. Это, в конце концов, так же как мы обычно пишем синхронный код (например `TResult result = SomeOperation();`), и это естественно транслируется в `async/await`.

Более того, Task имеет потенциальный недостаток, например в тех случаях когда часто создаются экземпляры этого класса, при том что высокая пропускная способности и производительность кода являются ключивыми. Task - это класс. А это значит, что каждая операция которая создает экземпляр задачи аллоцирует объект, чем больше объектов мы аллоцируем, тем больше требоуется работы со стороны GC, и тем больше тратиться ресурсов на работу сборщика мусоар, ресурсов, которые могли бы быть использованы на другие цели.

Среда выполнения и основные библиотеки смаягчают это во многих ситуациях. Например, если вы пишите метод как приведен ниже:
```csharp
public async Task WriteAsync(byte value)
{
    if (_bufferedCount == _buffer.Length)
    {
        await FlushAsync();
    }
    _buffer[_bufferedCount++] = value;
}
```
в общем случае, в буфере будет достаточно место, и операция завершиться синхронно. Если это так, то нет ничего особенного в возвращаемой задаче, т.е. нет возвращаемого значения, дургими словами, мы имеем дело с Task - эквиволентом синхронной операции с "пустым" (`void`) возвратом. Таким образом, среда выполнения просто кэширует единственную нетипизируемую задачу и использует ее каждый раз как результат для любого async Task метода, который завершается синхронно (кэшируется сингелтон представляемый статическим свойством Task.ComletedTask). Или, к примеру, если вы напишете:
```csharp
public async Task<bool> MoveNextAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
    return _bufferedCount > 0;
}
```
В общем случае мы ожидаем, что в буфере есть некоторые данные. В таком случае метод проверяет `_bufferedCount`, видит что переменная больше нуля, и возвращает `true`. Только если на момент проверки данные не были буфирезированы, требуется выполнить асинхронную операцию. Таким образом есть только два возможных логических результата (`true` и `false`), и только два возможных состояния возврата `Task<bool>`. В таком случае, среда кэширует два таких объекта, и просто возвращает закэшированный `Task<bool>` с результатом `true`, избегая аллокации. Только в случае если операция завершается асинхронно, для возврата методу приходится аллоцировать новый экземпляр Task<bool>, т.к. ему требуется вернуть объект вызывающей стороне, прежде чем будет известен результат операции, и требуется иметь уникальный объект, в который метод сохранит реузльтат, когда операция завершиться.
    
    
Среда выполнения делает такого рода кэширования и в других случаях, но не возможно так делать везде. Например, методе:
```csharp
public async Task<int> ReadNextByteAsync()
{
    if (_bufferedCount == 0)
    {
        await FillBuffer();
    }
 
    if (_bufferedCount == 0)
    {
        return -1;
    }
 
    _bufferedCount--;
    return _buffer[_position++];
}
```
так же, часто завершается синхронно. Но, в отличее от предыдущего примера, этот метод возвращает целочисленный результат, который имеет примерно четыре миллиарда возможных значений, и кэширование `Task<int>` в этой ситуации потребовало бы, потенциально, гигабайтов памяти. Среда поддерживает небольшой кэш для `Task<int>`, но только для нескольких небольших значений. Так, например, если операция завершится синхронно (данные присутствуют в буфере), со значением как 4, это приведет к использованию кэша, но если результатом будет синхронное завершение со значением 42, это приведет к созданию нового экземпляра `Task<int>`, аналогично вызову `Task.FromResult(42)`.

Многие реализации библиотеки пытаются смягчить такие ситуации посредством поддержки своих собственных кэшей. К примеру, перегрузка `MemoryStream.ReadAsync`, введенная в .NET Framework 4.5, всегда завершается синхронно, т.к. это всего лишь чтение из памяти. `ReadAsync ` возвращает `Task<int>`, где целочисленный результат представляет число прочитанных байтов. `ReadAsync` не редко используется в цикле, при этом количество запрашиваемых байтов не меняется от итерации к итерации, в таких случаях, довольно часто `ReadAsync` может прочитать запрошенное количество байт. Таким образом, для повторяющихся вызовов `ReadAsync` выполняется синхронно и возвращает объект `Task<int>`  с тем же результатом что и на предыдущей итерации. По этой причине, `MemoryStream` кэширует крайнюю успешно выполненнную задачу. Зате, для всех последующих вызовов, если новый результат совпадает с тем что был закэширован, возвращается `Task<int>` из кэша. Если же результат не совпадает, то используется `Task.FromResult` для создания нового экземпляра, этот экземпляр сохраняется в кэше и возвращается вызывающей стороне.

Не смотря на это, существует много случаев, когда операция завершается синхронно, и при этом вынуждена аллоцировать и возвращать новый экземпляр `Task<TResult>`.


## ValueTask\<TResult\> и синхронное завершение.

Все это послужило мотивацией для введения в .NET Core 2.0 нового типа `ValueTask<TResult>`. Так же, этот тип сделали доступным в других  релизах .NET через nuget-пакет `System.Threading.Tasks.Extensions`.

`ValueTask<TResult>` был введен в .NET Core 2.0 как структура, способная оборачивать `TResult` или `Task<TResult>`. Это знчаит что объекты этого типа могут быть возвращены из async-метода, и если метод завершился успешно и синхронно, нам нет необходимости создавать что-либо в куче, мы просто инициализируем экземпляр `ValueTask<TResult>` со значением результата, и возвращаем его. Только если метод завершается асинхронно, нам необходимо создать `Task<TResult>`. В этом случаае `ValueTask<TResult>` создается как обертка над `Task<TResult>`. Это сделано для минимизации структуры `ValueTask<TResult>`, т.к. и в случае успеха, и в случае неудачи, асинхронный метод возвращает `Task<TResult>`, то чтобы не хранить дополнительные поля (например для хранения исключения) на оба случая в экземплярах `ValueTask<TResult>`, он просто агригирует возвращаемый `Task<TResult>`.

Учитывае вышеизложенное, например в методе `MemoryStream.ReadAsync`, и подобных ему, больше нет необходимости заниматься кэшированием, вместо этого его можно реализовывать следующим образом:
```csharp
public override ValueTask<int> ReadAsync(byte[] buffer, int offset, int count)
{
    try
    {
        int bytesRead = Read(buffer, offset, count);
        return new ValueTask<int>(bytesRead);
    }
    catch (Exception e)
    {
        return new ValueTask<int>(Task.FromException<int>(e));
    }
}
```

## ValueTask\<TResult\> и асинхронное завершение.

Иметь возможность писать асинхронные методы, при синхронном завершении, не требуют дополнительных аллокаций памяти для результата, это большой успех. Именно для этого `ValueTask<TResult>` был добавлен в .NET Core 2.0, и все новые методы, которые, как ожидается, будут использоваться на "горячих путях", теперь в качестве возвращаемого занчения указывают тип `ValueTask<TResult>` вместо  `Task<TResult>`. К примеру, новая перегрузка метода `ReadAsync` для `Stream`, в .NET Core 2.1 (принимающая в качестве параметра `Memory<byte>` вместо `byte[]`), возвращает экземпляр `ValueTask<int>`. Что позволило значительно снизить колличество аллокаций при работе с потоками (очень часто метод `ReadAsync` заверщается синхронно, как и в примере с `MemoryStream`). 

Однако, при разработке сервисов с высокой пропускной способностью, нам тоже нужно всеми силами стараться избегать дополнительных аллокаций. Это значит что необходимо задуматься о снижении числа аллокаций связанных с асинхронным завершением операций.

В модели async/await, для людой операции которая заканчивается асинхронно, нам нужна возможность вернуть объект для ожидание завершение операции - клиент должен иметь возможность передать делегат обратного вызова, который будет выполнен по заверешнию операции, что требует наличия уникального объекта в куче, который будет служить как калан выполнения обратного вызова. Отметим, однако, ни чего не говорит о том, можно ли повторно переиспользовать возвращенный объект ожидания, после завершения асинхронной операции. Если объект может быть переиспользован, то API может поддерживать кэш для такого рода объектов. Но в таком случае этот пул не может подерживать конкурентный доступ.

Для поддержки возможности работы с такого рода пулами, в .NET Core 2.1 был добавлен интерфейс `IValueTaskSource<TResult>`, а стурктура `ValueTask<TResult>` был расширена, для возможности агригации не только, помимо `TResult` и `Task<TResult>`, но и экземпляров `IValueTaskSource<TResult>`. Этот интерфейс обеспечивает базовую поддержку, необходимую для представления асинхронных операций через `ValueTask<TResult>`, в той же манери что и через `Task<TResult>`:
```csharp
public interface IValueTaskSource<out TResult>
{
    ValueTaskSourceStatus GetStatus(short token);
    void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    TResult GetResult(short token);
}
```
`GetStatus` предназначен для поддержки свойств типа `ValueTask<TResult>.IsCompleted`, позволяет узнать завершилась ли операция, и если да, то успешно или нет. `OnCompleted` используется в `ValueTask<TResult>` для запуска обратного вызова, по завершению асинхронной операции. `GetResult` используется для получения результата операции, или для распространения возникшего, в асинхронной операции, исключения.

У большенства разработчиков вряд ли когда либо возникнет необходимость иметь дело с интерфейсом `IValueTaskSource<TResult>`, т.к. асинхронные методы возвращают оборачивающий его `ValueTask<TResult>`. Сам интерфейс в первую очередь предназначен для тех программистов, которые разрабатывают производительные API, стремящихеся избежать излишних аллокаций памяти. 

Можно выделить несколько такого рода API в .NET Core 2.1. Наиболее известный это новые перегрузки методов `Socket.ReceiveAsync` и `Socket.SendAsync`. К примеру:
```csharp	
public ValueTask<int> ReceiveAsync(Memory<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);
```
В качестве возвращаемого значения, используются экземпляры типа `ValueTask<int>`.
Если метод завершается синхронно, то он возвращает `ValueTask<int>` с соответствующим значением: 

```csharp
int result = …;
return new ValueTask<int>(result);
```

Если же операция завершается асинхронно, то использется кэшируемый объект, реализующий интерфейс `IValueTaskSource<TResult>`:
```csharp
IValueTaskSource<int> vts = …;
return new ValueTask<int>(vts);
```
Реализация `Socket` поддерживает один кэшируемый объект для получения, и один для отправления данных, до тех пор, пока каждый используется один за раз. Это снижает количество дополнительного выделения памяти, даже в случае асинхронного выполнения.
Например, в .NET Core 2.1, `NetworkStream` перегружает метод `ReadAsync` класса `Stream`:
```csharp
public virtual ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken);
```
Перегрузка этого метода в `NetworkStream` просто делегирует работу метроду `Socket.ReceiveAsync`, а значит повышение эффективности, в плане работы спамятью, метода сокета, повышиет эффективность и метода `NetworkStream`.


## Non-generic ValueTask
Целью введения `ValueTask<T>` в .NET Core 2.0 была только оптимизация случаев синхронного завершения, чтобы избежать создания `Task<TResult>` для сохранения уже полученного результата `TResult`. Это так же значит, что не было необходимости в нетипизируемом  `ValueTask`: в случаях синхронного завершения методы используют синглтон через свойство `Task.CompletedTask`, это же, неявным образом, делает среда выполнения для `async Task`-методов.

Но, с появлением возможности избегать лишних аллокаций и при асинхронном завершении, необходимость в нетипизированном `ValueTask` сново стала актуальна. По этой причине, в .NET Core 2.1 мы ввели нетипизируемые `ValueTask` и `IValueTaskSource`.  Они являются аналогами соответствующих обобщенных типов, и использются тем же образом, но при отсутствии возвращаемого значения.


## Реалзиация IValueTaskSource / IValueTaskSource\<T\>

У большенства разработчиков не возникнит необходимости реализовывать эти интерфейсы. Кроме того, их реализация это не простая задача. Если же вы решити, что вам необходима реализовать эти интерфейсы, то существует несколько примеров внутри .NET Core 2.1, которые могут послужить в качестве примеров:
* [AwaitableSocketAsyncEventArgs](https://github.com/dotnet/corefx/blob/61f51e6b2b26271de205eb8a14236afef482971b/src/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs#L808)  
* [AsyncOperation\<TResult\>](https://github.com/dotnet/corefx/blob/89ab1e83a7e00d869e1580151e24f01226acaf3f/src/System.Threading.Channels/src/System/Threading/Channels/AsyncOperation.cs#L37)  
* [DefaultPipeReader](https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/System.IO.Pipelines/src/System/IO/Pipelines/Pipe.DefaultPipeReader.cs#L16)  

Для упращения это задачи, для разработчков которые захотят сделать свои реализации, мы планируем представить в .NET Core 3.0 тип `ManualResetValueTaskSourceCore<TResult>`. Эта структура будет реализовывать всю необходимую логику. Экземпляр `ManualResetValueTaskSourceCore<TResult>`, можно будет инкапсулировать в другом объекте, реализующем `IValueTaskSource<TResult>` и / или `IValueTaskSource`, и делегировать ему большую часть функционала. Вы можете больше узнать об этом в связанном issue в репозитории dotnet/corefx по ссылке ttps://github.com/dotnet/corefx/issues/32664.
  
## Правильная модель использования ValueTasks
При поверхностном рассмотрении видно что `ValueTask` and `ValueTask<TResult>` более ограниченны чем `Task` и `Task<TResult>`. И это нормально, даже желательно, ведь основная цель - это ожитдать завершения асинхронного выполнения.

Все же, т.к. `ValueTask` and `ValueTask<TResult>` могут агрегировать переиспользуемые обхекты, существуют значительные ограничения в их использовании, по сравнению с `Task` and `Task<TResult>`. В общем, следующие операции **НИКОГДА* не должны выполняться при использовании `ValueTask` / `ValueTask<TResult>`:

* **Многократное ожидание `ValueTask` / `ValueTask<TResult>`**. Экземпляры `Task` и `Task<TResult>` никогда не возвращаются из "завершенного" состояния в "незавершенное", их мы можем использовать для ожидания результата столько раз сколько захотим, и всегда получать один и тот же результат. В отличие от них, `ValueTask` / `ValueTask<TResult>`, могут выступать обертками над переиспользуемыми объектами, что значит, что их состояние может изменяться, переходить от "завершенного" в "незавершонное" и обратно. 

* **Ожидать `ValueTask` / `ValueTask<TResult>` конкурентно**. Обернутый объект ожидает работать только с одним обратным вызововм, от единственного потребителя, за раз, и попытка конкурентного ожидания может легко привести к состоянию гонки и "тонким" програмным ошибкам. Конкурентное ожидания, это один из вариантов, описанного вышел **многократного ожидания**. Отметим, что `Task` / `Task<TResult>` допускают любое число конкурентных ожиданий.

* **Использование `.GetAwaiter().GetResult()` до завершения операции**. Реализации `IValueTaskSource` / `IValueTaskSource<TResult>` не должны поддерживать блокировку до завершения операци. Блокировка, по сути, приводит к состоянию гонки, и вряд ли это будет ожидаемое, со стороны потребителя, поведение. В то время как `Task` / `Task<TResult>` позволяют сделать это, тем самым заблокировать вызывающий поток до завершения операции.

Если у вас есть экземпляры `ValueTask` / `ValueTask<TResult>`, и вам требуется сделать одну из вышеописанных операций, вы должны использовать метод `.AsTask()` чтобы получить `Task` / `Task<TResult>`, и только после этого выполнить нужную операцию на возвращенном (из `.AsTask()`) объекте. После этого, вы больше не должны использовать исходные `ValueTask` / `ValueTask<TResult>`.

**Корокое правило гласит**: При работе с `ValueTask` / `ValueTask<TResult>` вы должны либо ожидать (`await`) их напрямую (или, если нужно с `.ConfigureAwait(false)`) или напрямую вызвать у объекта `.AsTask()`, и больше его никогда не использовать.

```csharp
// Given this ValueTask<int>-returning method…
public ValueTask<int> SomeValueTaskReturningMethodAsync();
…
// GOOD
int result = await SomeValueTaskReturningMethodAsync();
 
// GOOD
int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false);
 
// GOOD
Task<int> t = SomeValueTaskReturningMethodAsync().AsTask();
 
// WARNING
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
... // storing the instance into a local makes it much more likely it'll be misused,
    // but it could still be ok
 
// BAD: awaits multiple times
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
int result = await vt;
int result2 = await vt;
 
// BAD: awaits concurrently (and, by definition then, multiple times)
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
Task.Run(async () => await vt);
Task.Run(async () => await vt);
 
// BAD: uses GetAwaiter().GetResult() when it's not known to be done
ValueTask<int> vt = SomeValueTaskReturningMethodAsync();
int result = vt.GetAwaiter().GetResult();
```

Есть еще один дополнительный, "продвинутый", шаблон использования, который некоторые программисты могут решить использовать, надеюсь только после аккуратных измерений, с обоснованием значимой пользы от него.

Конкретно объекты типов `ValueTask` / `ValueTask<TResult>` имеют некоторые свойства, которые позволяют узнать о текущем состоянии операции. К примеру свойство `IsCompleted` вернет `true`, если операция завершена (успешно или с исключением, не важно), в противном случае - `false`, а `IsCompletedSuccessfully` вернет `true` только в том случае, если операция завершилась успешно. Для самых "гоячих" путей, где разработчик хочет, например, избежать дополнительных накладных расходов, которые неменуемы только при асинхронном выполнении, можно использовать вышеуказанные свойства. Так мы можем проверить состояние выполнения и решить надо ли использовать `await` / `.AsTask()`. Например, реализация класса `SocketsHttpHandler` в .NET Core 2.1, этот код имеет дело с методом `.ReadAsync` соединения, который возвращает `ValueTask<int>`. Если операция завершается синхронно, нам более не надо волноваться о возможности её отмены. Но если операция будет выполняться асинхронно, то мы хотим иметь возможность обработать запрос отмены т.к. он разорвет соединение. Т.к. это высоконагруженныая часть кода, и профилирование показало небольшое различие, код, по существу, был структурирован следующим обрзаом:
```csharp
int bytesRead;
{
    ValueTask<int> readTask = _connection.ReadAsync(buffer);
    if (readTask.IsCompletedSuccessfully)
    {
        bytesRead = readTask.Result;
    }
    else
    {
        using (_connection.RegisterCancellation())
        {
            bytesRead = await readTask;
        }
    }
}
```
Здесь вышеописаный шаблон применим, т.к. `ValueTask<int>`, ни в случае вызова `.Result`, ни в случае `await`, ни где более не используется.


## Should every new asynchronous API return ValueTask / ValueTask\<TResult\>?
  
## What’s Next for ValueTask and ValueTask\<TResult\>?

