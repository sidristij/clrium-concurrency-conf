# ValueTask Что? Где? Когда?.
автор: *Stephen*  
перевод *Гончаров А.В*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/) 

В вышедшем .NET Framework 4 было впервые представлено пространство имен `System.Threading.Tasks` и в нем, класс `Task`. Этот тип, и его производный `Task<TResult>` давно стали одной из основ программирования на .NET, ключевыми аспектами асинхронной модели, реализованной в C# 5, с его ключевыми словами `async/await`. В этой статье я расскажу о новых типап `ValueTask/ValueTask<TResult>`, которые были введены с целью улучшить производительность асинхронного кода, в тех случаях, когда важно снижение накладных расходов при работе с памятью. 

## Task
Task служит нескольким целям, но основной из них это "promise" - отбъект, представляющий собой завершение какой-либо операции. Вы инициируете операцию и получаете Task, этот Task будет завершен когда завершиться операция, что может происходить синхронно, как часть инициатора операции (например доступ к некоторым данным, которые уже буферезированы), либо же асинхронно, но завершиться к тому моменту, когда вы получите Task (например быстрый доступ к данным, которые еще не были буфиризированны), или же асинхронно, после того как вы получили Task (например, при получении данных по сети). Поскольку операции могут завершаться асинхронно, вам либо надо блокировать поток в ожидании результата (что, часто, противоречить цели по которой операция выполняется асинхронно), либо же вы предоставляете метод обратного вызова, который будет выполнен по завершению асинхронной операции. Модель обратного вызова в .NET 4 была представлена явным образом посредством метода ContinueWith объекта класса Task, пренемавшего на вход делегат, который вызывался по завершению задачи.

```csharp
SomeOperationAsync().ContinueWith(task =>
{
    try
    {
        TResult result = task.Result;
        UseResult(result);
    }
    catch (Exception e)
    {
        HandleException(e);
    }
});
```
Но с версии .NET Frmaework 4.5 и C# 5, задачи стали просто ожидаться (`await`ed), упращая получения результатов асинхронных операций. А генерируемый код был способен оптимизировать все упомянутые выше операции, корректно обрабатывая завершение, не смотря на то, была ли операция завершина синхронно, асинхронно, но быстро, или же асинхронно, после (уже неявно) предоставления делегата обратного вызова.   
```csharp
TResult result = await SomeOperationAsync();
UseResult(result);
```


## ValueTask\<TResult\> and synchronous completion

## ValueTask\<TResult\> and asynchronous completion

## Non-generic ValueTask

## Implementing IValueTaskSource / IValueTaskSource\<T\>

## Valid consumption patterns for ValueTasks

## Should every new asynchronous API return ValueTask / ValueTask\<TResult\>?
  
## What’s Next for ValueTask and ValueTask\<TResult\>?

