# ConfigureAwait, *кто виноват и что делать*?
*Гончаров А.В.*
### Введение.
В своей практики я часто встречаю, в различном *окружении*, код вроде:
```C#
[1] var x = FooWithResultAsync(/*...*/).Result;

//или 
[2] FooAsync(/*...*/).Wait(); 

//или 
[3] FooAsync(/*...*/).GetAwaiter().GetResult();

//или 
[4] FooAsync(/*...*/)
			.ConfigureAwait(false)
			.GetAwaiter()
			.GetResult();

//или			
[5] await FooAsync(/*...*/).ConfigureAwait(false)

//или просто
[6] awiat FooAsync(/*...*/)	
```
Общаясь с программистами, авторами такого кода, стало ясно, что все они делятся на три группы:  
Первая группа, это те, кому  не известно о возможных проблемах с вызовом `Result/Wait/GetResult`. Пример кода (1-3) и, иногда, (6), типичны для программистов из этой группы.<cut/>
Ко второй группе относятся программисты, которым известно о проблеме, но у них нет понимая причин. В коде разработчиков этой группы почти всегда встречается код вроде (1-5)  
Третья группа - это те программисты, которые знают суть вопроса. 
А проблемы со всеми примерами кода есть. На сколько серьезны эти проблемы, зависит от *окружения* в котором  приведенные примеры кода, написаны.
### В чем проблемы?
Можно выделить две проблемы которые возникают с асинхронным кодом. 
В примерах с 1-го по 4-й мы имеем смешивание синхронного кода с вызовом асинхронного метода, с последующей блокировкой клиентского потока через вызов `Result/Wait/GetResult`. Блокировка потока, чаще всего, это плохая идея. Для простоты, будем считать, что все потоки выделяются из некоторого пула потоков. Если в программе присутствует код с блокировкой, то это может привести к выборке всех потоков из пула. В лучшем случае, это замедлит работу программы и приведет к не эффективному использованию ресурсов. В худшем же случае, это может привести к дедлоку. Дедлок может получиться, если происходит вызов с последующей блокировкой, к примеру, одного и того же асинхронного метода, который, в свою очередь, так же делает асинхронный вызов. В конечном итоге, когда в пуле уже не останется потоков, а методу нужен будет еще одни, чтобы продолжить работу и завершить ее, возникнет дедлок. 

Но все становится гораздо хуже, когда мы работаем в окружении, в котором значительную роль играет контекстом синхронизации. При наличии *особого* контекста синхронизации, смешивание синхронного и асинхронного кода, т.е. код с блокировкой, повышает  вероятность возникновения дедлоков многократно.
Так, код из примера (1-3), если он выполняется, к примеру, в UI-потоке WinFoms, гарантированно создает дедлок. И добавление `ConfigureAwait(false)`, как в примере (4),  не даст 100% гарантии  защиты от дедлока. Ниже приведен пример классического дедлока в WinForms, не смотря на наличие `ConfigureAwait(false)`:
```C#
async Task FooAsync()
{			
	await Task.Delay(5000);
}

private void button1_Click(object sender, EventArgs e)
{
	FooAsync()
		.ConfigureAwait(false)
		.GetAwaiter()
		.GetResult();
	button1.Text = "new text";
}
```

В статье [1](https://msdn.microsoft.com/en-us/magazine/gg598924.aspx) можно найти информацию о различных контекстах синхронизации.

Понять причину возникновения дедлока просто, если вспомнить как выглядит код конечного автомата, в который преобразуется вызов async метода. Достаточно подробный код генерируемого конечного автомата, можно найти, например, в статье [2](https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine). Вся "магия" заключается в строчке :
```C#
//
_builder.AwaitUnsafeOnCompleted<TaskAwaiter, ThisStateMachine>(ref taskAwaiter, ref this);
```
Это код выполняется, если внутренний асинхронный вызов еще не был завершен, а следовательно текущий поток можно освободить. 
Если погрузиться в дебри исходного кода MS, который скрывается под этой строчкой, вы придете к классу [SynchronizationContextAwaitTaskContinuation](https://referencesource.microsoft.com/mscorlib/R/d8b8d04cc476b392.html), и его базовому классу [AwaitTaskContinuation](https://referencesource.microsoft.com/mscorlib/system/threading/Tasks/TaskContinuation.cs.html#3f97ac52ec881e24), где и находится ответ на все вопросы.

Для простоты я позволю себе написать сильно упрощенный  "аналог" кода, даже без конечного автомата, в терминах TPL. Вся суть сводиться к следующему: 
Рассмотрим такой код:
```C#
[7]
async Task FooAsync()
{			
		await Task.Delay(5000);
		//Остальную часть кода метода объединим в метод 
		RestPartOfMethodCode();	
}

private void button1_Click(object sender, EventArgs e)
{
	FooAsync().Wait();
	button1.Text = "new text";
}
```		 
Его вызов превратиться в конечный автомат, который аналогичен, в первом приближении, следующему коду:
```C#
[8]
Task FooAsync()
{		
	// Переменная methodCompleted вводится только для того, чтобы подчеркнуть, 
	// что метод завершается только когда будет выполнен некоторый "маркерующий код".
	// В конечном автомате функцию, аналогичную строчке methodCompleted.WaitOne() данного кода,
	// выполняет метод SetResult класса AsyncTaskMethodBuilder, 
	// объект которого храниться в поле конечного автомата.
	var methodCompleted = new AutoResetEvent(false); 	
	
	SynchronizationContext current = SynchronizationContext.Current;	
	return Task.Delay(5000).ContinueWith(
		t=>
		{			
			if(current == null)
			{
				RestPartOfMethodCode();
			}
			else
			{
				current.Post(state=>RestPartOfMethodCode(methodCompleted), null);
				methodCompleted.WaitOne();				
			}					
		}, 
		TaskScheduler.Current);	      			
}
```
Этот код *очень условно* повторяет реальный, но дает более наглядное представление того что происходит.
А происходит вот что: При наличии контектса синхронизации, весь код асинхронного метода, который идет после завершения внутреннего асинхронного вызова, выполняется через посредством делегата через контекст синхронизации (`current.Post(...)`). 
Если речь идет о WinForms приложении, то контекст синхронизации в нем связан с UI-потоком. Если UI-поток заблокирован, в примере  (7) это происходит через вызов `Wait()`, то оставшаяся часть кода асинхронного метода выполнится не может, а значит асинхронный метод не может завершиться, и не может освободить UI-поток,  что и есть дедлок.

Когда мы вызываем `ConfigureAwait(false)`, то мы сообщаем среде, что для выполнения оставшейся части кода не нужно использовать контекст синхронизации. В этом случае код будет выполнятся в том потоке который был получен по завершению внутреннего асинхронного вызова, это соответствует, в нашем коде, ветке `if(current == null)`. 

Но, как я писал выше, вызов `ConfigureAwait(false)` в клиентском коде, в общем случае, не гарантирует решения проблемы с дедлоком. Чтобы этой проблемы не было, внутренний асинхронный вызов функции `FooAsync` должен быть также сконфигурирован через `ConfigureAwait(false)`, как в примере (9):
```C#
[9]
async Task FooAsync()
{			
		await Task.Delay(5000).ConfigureAwait(false);
		//Остальную часть кода метода объединим в метод 
		RestPartOfMethodCode();	
}

private void button1_Click(object sender, EventArgs e)
{
	FooAsync().ConfigureAwait(false)
	.GetAwaiter().GetResult();
		
	button1.Text = "new text";
}
```		 

Надеюсь что приведенный мой пример достаточно прост для понимания, и не сильно все упрощает, тем более, не вводит в заблуждение (с точки зрения тех, кто знает как все сделано на самом деле).

### Кто виноват?
Как всегда, правильным ответом на этот вопрос будет "все". Начнем с архитекторов и программистов из MS. С одной стороны, разработчики из MS, приняли решение, что правильным будет поведение, когда, по умолчанию, работа идет через контекст синхронизации, если он есть. И это логично, иначе зачем он еще нужен. И, как я полагаю, они ожидали что разработчики клиентского кода не будут блокировать основной поток там, где контекст синхронизации на это завязан. С другой стороны, они дали очень простой инструмент чтобы выстрелить себе в ногу - слишком просто и удобно получать результат через `.Result/.GetResult`, или блокировать поток через `.Wait`. В чем же виноваты разработчики клиентского кода? В том что часто не пытаются разобраться в своем инструменте и пренебрегают предупреждениями.
### Что делать?  
Далее я приведу мои рекомендации:
##### Для разработчиков клиентского кода:
 1. Всеми силами  избегайте блокировок. Или другими словами, не смешивайте синхронный и асинхронный код, без особой необходимости.

 3. Если приходится делать блокировку, то определите в каком окружении выполняется код: 
	 *  Есть ли контекст синхронизации? Если да, то какой? Какие особенности он привносит в работу? 
	* Если контекста синхронизации "нет", то: Какова будет нагрузка? 		Какова вероятность того, что потоков, созданных на старте, в пуле может не хватить?

Исходя из всей информации принимайте решение. Возможно вам поможет `ConfigureAwait`, а может он вам не нужен. 
##### Для разработчиков библиотек:
Во-первых. Если вы полагаете что ваш код может быть вызван из "синхронного" кода, то обязательно реализуйте синхронный API. Он должен быть по-настоящему синхронным. Т.е. вы должны пользоваться синхронным API библиотек третьей стороны.
Во-вторых `ConfigureAwait(false)`. 
Тут, с моей точки зрения, необходим более тонкий подход чем обычно рекомендуют.
Во многих статьях говориться, что в библиотечном коде, все асинхронные вызовы надо конфигурировать через `ConfigureAwait(false)`.  Я не могу с этим согласиться. Возможно, с точки зрения авторов, коллеги из MS принял не верное решение при выборе стратегии "по умолчанию"  в отношении работы с контекстом  синхронизации. Но они (MS), все же, оставили возможность разработчикам клиентского кода изменить это поведение. Стратегия, когда библиотечный код полностью покрывается  `ConfigureAwait(false)`, изменяет  поведение по умолчанию, но, кроме этого, такой подход лишает разработчиков возможности выбора.

Я предлагаю другой подход. При реализации асинхронного API, в каждый метод API добавлять два  дополнительных входных параметра: `CancellationToken token` и ` bool continueOnCapturedContext`. И реализовывать код в виде пары методов, как показано в следующем примере:
```C#
public ConfiguredTaskAwaitable<string> FooAsync(
	/*другие аргументы функции*/
	CancellationToken? token = null, 
	bool continueOnCapturedContext = true)
{
	return InnerFooAsync(
		/*другие аргументы функции*/, 
		token ?? CancellationToken.None, 
		continueOnCapturedContext).ConfigureAwait(continueOnCapturedContext);
}

private async Task<string> InnerFooAsync(
	/*другие аргументы функции*/,
	CancellationToken token, 
	bool continueOnCapturedContext)
{
	// ...
	await Task.Delay(30, token).ConfigureAwait(continueOnCapturedContext);
	// ...
	return result;
}
```
Первый параметр, `token` - служит для возможности скоординированной отмены (чем разработчики библиотек, так же, не редко пренебрегают).  Второй, `continueOnCapturedContext` - позволяет настроить взаимодействие с контекстом синхронизации. 
Пара методов сделана для того, чтобы после вызова метода API, и передачи ему значения `continueOnCapturedContext`, клиентскому коду не требовалось дополнительного вызова  `ConfigureAwait` в отношении `Task` возвращенного методом API:
```C#
// Пример вызова в асинхронном коде:
async Task ClientFoo() 
{
	//...
	await FooAsync(
		/*другие аргументы функции*/,
		ancellationToken.None, 
		false);
	//...
}

//В синхронном, с блокировкой.
private void button1_Click(object sender, EventArgs e)
{
	FooAsync(
		/*другие аргументы функции*/,		
		_source.Token, 
		false).GetAwaiter().GetResult();
			
		button1.Text = "new text";
}
``` 

### Заключение.
Главный вывод из всего вышеизложенного заключется в следующих трех мыслях: 
1. Блокировки - корень всех зол. Именно наличие блокировок может привести, в лучшем случае, к деградации производительности и не эффективному использованию ресурсов, в худшем - к дедлокам. Прежде чем использовать блокировки подуймайте нужно ли это? Возможно есть другой способ синхронизации данных / процессов.
2. Изучайте инструмент с которым работаете.
3. Если проектируете библиотеки, то старайтесь сделать так чтобы их правильное использование было легким, почти интуитивным, а неправильное было сопряжено со сложностями.


Я постарался максимально просто объяснить причину проблем, о которых много уже что говорилось и писалось. А так же, представил мое видение решения этих проблем.  Надеюсь, что это мне удалось, и материал будет полезен читателю.  Лучшим способом понять как все работает на самом деле, с моей точки зрения, это обратиться к исходникам. Это можно сделать через репозитории MS на [GitHub](https://github.com/microsoft/referencesource/tree/master/mscorlib/system/threading/Tasks) или, так даже удобнее, через сайт самого [MS](https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/).

*P.S.* Буду благодарен за конструктивную критику.
