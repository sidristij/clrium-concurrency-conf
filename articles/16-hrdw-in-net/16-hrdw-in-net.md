# Встроенные функции аппаратного обеспечения в .NET Core
автор: *Tanner Gooding*  
перевод: *Андрей Гончаров*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/) 

### Предисловие к переводу
*Мне нравиться наблюдать за развитием платформы .NET, а точнее языка C#. Придя из мира C++, и имеея небольшой опыт разработки на Delphy мне было очень комфортно начать писать программы на C#. В 2006 году этот язык программирования (именно язык) мне показался более лаконичным, чем Java, в мире управляемой сборки мусора и кросплатформенности. Поэтому мой выбор пал на С#, и я не пожалел. В 2010-м, в широкий доступ вышел F#. Он был эксперементальной площадкой для изучения функциональной парадигмы с целью внедрения ее в мир .NET. Результатом эксперементов стал следующий этап в эволюции C# - расширение его возможностей в сторону ФП, за счет введения анонимных функции, лямбда выражений, и, в конечном итоге, LINQ. Такое расширение языка сделало C# самым продвинутым, с моей точки зрения, языком общего назначения. Следующий шаг эволюции был связан с поддержкой параллелилизма и асинхронности. Task/Task&lt;T&gt;, вся концепция TPL, развитие LINQ - PLINQ, и, в конце концов, async/await. И вот, в последние два-три года, мы наблюдаем новый этап эволюции платформы .NET и языка C# - движение в сторону обеспечения высокопроизводительных вычислений. Сюда относятся введение Span&lt;T&gt; и Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct и квалификатор in, асинхронынй foreach, IO.Streams. Все эти нововведения направлены на снижение нагрузки на GC и повышения производетельнсоти кода. В этой статье, представлен следующий шаг в этом направлении - предоставления разработчику доступа к функциям аппаратного обеспечения. Я рад, что в разработке платформы .NET и языка C#, в частности, участвую инжинеры с такими широкими и разносторонними взглядами и интересами. Надеюсь увидеть (а может даже приложить свою руку к этому) еще много интересных поворотов в развитии платформы и языка.*

## Введение
Несколько лет назад, [мы решили что настало время поддержать SIMD код в .NET](https://devblogs.microsoft.com/dotnet/the-jit-finally-proposed-jit-and-simd-are-getting-married/). Мы представили пространство имен `System.Numerics` с типами `Vector2`, `Vector3`,`Vector4` и `Vector<T>`. Эти типы представляют API общего назначения для создания, доступа и оперирования векторных инструкций, когда это возможно. Они, так же, обеспечивают програмную совместимость для тех случаев, где аппаратное обеспечение не поддерживает подходящих инструкций. Это позволило с минимальным рефакторингом векторизовать ряд алгоритмов. Как бы там ни было, общность такого подхода делает его сложным в применении с целью получения полного приемущество от всех доступных, на современном аппаратном обеспечении, векторных инструкций. В дополнении, современное аппаратное обеспечение предосталяет ряд специализированных, не векторны, инструкций, которые могут значительно улучшать производительность. В этой статье, я расскажу как мы справились с этими ограничениями в .NET Core 3.0.

## Что такое встроенные функции аппаратного обеспечения (ВФАО).
В .NET Core 3.0 мы добавили новую фичу под названием *аппаратные встроенные функции*. Эти функции обеспечивают доступ ко многим специфичным инструкциям аппаратного обеспечения, которые не могут быть легко представлены механизмами более общего назначения. Они отличаются от существующих SIMD функций, тем что они не имеют общего назначения (новые ВФАО не являются кросс-платформенными и их архитектура не обеспечивает программной совместимости), вместо этого, они напрямую обеспечивают платформенно и аппартно зависимую функциональность для разработчиков .NET. Существующие SIMD встроенные функции, к примеру, кросс-платформенные, обеспечивают програмную совместимости, и они слегка абстрагированны от лежащего под ними аппаратного обеспечения. Эта абстракция может быть дорогостоящей, к тому же она может препятствовать раскрытию некоторой функциональности (когда, например, функциональность не существует, или сложно эмулирема на всех целевых платформах).

Новые встроенные функции и поддерживаемые типы расположены по пространством имен `System.Runtime.Intrinsics`. Для .NET Core 3.0, в настоящий момент, существует одно пространство имен `System.Runtime.Intrinsics.X86`. Мы работаем над поддержкой ВФАО для другх платформ, таких как `System.Runtime.Intrinsics.Arm`. 

Под платформо-специфичными пространствами имён встроенные функции группируются в классы, которые представляют группы логически объединённых инструкций аппаратного обеспечения (часто называемые архитектурой набора команд). Каждый класс предоставляет свойство `IsSupported` указывающее поддерживает ли аппаратное обеспечение, на котором выполняется код, этот набор инструкций. Далее каждый такой класс содержит набор методов сопоставляемых с соответсвтвующим набором инструкций. Иногда существует дополнительнй подкласс, который соответсвует части того же набора команд, которая может ограничиваться спуццифичным аппаратным обеспечением. Например, класс `Lzcnt` обеспечивает доступ к *инструкциям подсчёта ведущих нулей*. У него существует подкласс, именуемый `X64`, которая содержит форму этих инструкций используемых только на машинах и 64 битной архитектурой. 

Некоторые из этих классов также имеют естественную иерархитескую структуру. Напримет, если `Lzcnt.X64.IsSupported` возвращает true, тогда `Lzcnt.IsSupported` также должны вернуть true. Так как это явный подкласс. Или, напрмер, если `Sse2.IsSupported` возвращает true, то и `Sse.IsSupported` должен вернуть true, потому что `Sse2` явным образом наследуется от `Sse`. Однако, стоит отметить, что схожесть имён классов не является показателем  принадлежности их к одной иерархии. Например, `Bmi2` не наследуются от `Bmi1`, поэтому значения возвращаемые `IsSupported` для этих двух наборов интсрукций будут отличаться. Основовополагающим принципом при разработке этих классов было явное представление ISA спецификаций. SSE2 требует поддержки SSE1, поэтому классы, представляющие их, связаны наследованием. В тоже время, BMI2 не требует поддержки BMI1, поэтому мы не использовали наследования. Далее представлен пример описанного выше API.

```csharp
namespace System.Runtime.Intrinsics.X86
{
    public abstract class Sse
    {
        public static bool IsSupported { get; }

        public static Vector128<float> Add(Vector128<float> left, Vector128<float> right);

        // Additional APIs

        public abstract class X64
        {
            public static bool IsSupported { get; }

            public static long ConvertToInt64(Vector128<float> value);

            // Additional APIs
        }
    }

    public abstract class Sse2 : Sse
    {
        public static new bool IsSupported { get; }
 
        public static Vector128<byte> Add(Vector128<byte> left, Vector128<byte> right);

        // Additional APIs
 
        public new abstract class X64 : Sse.X64
        {
            public static bool IsSupported { get; }

            public static long ConvertToInt64(Vector128<double> value);

            // Additional APIs
        }
    }
}
```

 Вы можете увидеть более полный список в исходном коде по следующим ссылкам [source.dot.net or dotnet/coreclr on GitHub](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Runtime/Intrinsics/X86/Sse.cs)

Проверки `IsSupported` обрабатываются JITом как константы времени выполнения (когда вкулчена оптимизация), поэтому вам не нужна кросс-компиляция для поддержки нескольких ISA, платформ или архитектур. Вместо этого вам достаточно написать код используюя `if`-выражения, в этом случае неиспользуемые ветки кода (т.е. те ветки кода, которые не достижимы в следствии значения переменной в условном операторе) будут отброшены при генерации нативного кода JIT-компилятором.

Важно чтобы проверка соответствующего `IsSupported` предшествовала использованияю встроенных команд аппаратного обеспечения. Если токой провероки нет, то при работе код, использующий платформенно-зависимые команды, на платформах/архитектурах где эти команды не поддерживаются, сгенерирует исключение времени выполнения `PlatformNotSupportedException`.

## Какие приемущество они дают?
Конечно встроенные функции аппаратного обеспечения не для всех, но они могут быть использованы для повышения производительности в нагруженных вычислениямии операциях. Такие фреймворки как `CoreFX` или [`ML.NET`](http://ml.net/) используют эти методы для ускорения таких операций как копирование в памяти, поис индекса элемента в массиве или строке, изменение размера изображения, или работа с векторами/матрицами/тензорами. Ручная векторизация некоторого кода, который оказался "узким горлышком", также может быть проще чем кажется. Векторизация кода, в действительности, это выполнения нескольких операций за раз, в общем случая используя SIMD-инструкции (один поток команд, множественный пото данных).

Перед тем как вы решите проводить векторизацию некоторого кода, необходимо провести профилирование, чтобы убедиться что этот код действительно является частью "горячей точки" (и, поэтому, ваша оптимизация даст существенный вклад). Также важно проводить профилирование на каждом этапе векторизации, так как векторизация не всякого кода приводит к повышению производительности.

## Векторизация простого алгоритма

Возмем для примера алгоритм суммирования всех элементов массива или диапазона. Такого рода код - это идиальный кандидат на векторизацию, т.к. на каждой итерации выполняется одна и таже тривиальная операция.

Пример реализации такого алгоритма может выглядить следующим образом:

```csharp
public int Sum(ReadOnlySpan<int> source)
{
    int result = 0;
            
    for (int i = 0; i < source.Length; i++)
    {
        result += source[i];
    }
            
    return result;
}
```

Этот код достаточно простой и понятный, но, также, достаточно медленный для входных данных большого размера, т.к. делают только одну тривиальную операцию за итерацию цикла.

```
BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362
AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores
.NET Core SDK=3.0.100-preview9-013775
  [Host]     : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT
```


|Method|Count    |Mean          |Error       |StdDev     |
|------|:-------:|:------------:|:----------:|----------:|
|Sum   |1        |2.477 ns      |0.0192 ns   | 0.0179 ns |
|Sum   |2        |2.164 ns      |0.0265 ns   |0.0235 ns  |
|Sum   |4        |3.224 ns      |0.0302 ns   |0.0267 ns  |
|Sum   |8        |4.347 ns      |0.0665 ns   |0.0622 ns  |
|Sum   |16       |8.444 ns      |0.2042 ns   |0.3734 ns  |
|Sum   |32       |13.963 ns     |0.2182 ns   |0.2041 ns  |
|Sum   |64       |50.374 ns     |0.2955 ns   |0.2620 ns  |
|Sum   |128      |60.139 ns     |0.3890 ns   |0.3639 ns  |
|Sum   |256      |106.416 ns    |0.6404 ns   |0.5990 ns  |
|Sum   |512      |291.450 ns    |3.5148 ns   |3.2878 ns  |
|Sum   |1024     |574.243 ns    |9.5851 ns   |8.4970 ns  |
|Sum   |2048     |1,137.819 ns  |5.9363 ns   |5.5529 ns  |
|Sum   |4096     |2,228.341 ns  |22.8882 ns  |21.4097 ns |
|Sum   |8192     |2,973.040 ns  |14.2863 ns  |12.6644 ns |
|Sum   |16384    |5,883.504 ns  |15.9619 ns  |14.9308 ns |
|Sum   |32768    |11,699.237 ns |104.0970 ns |97.3724 ns |


## Повышение производительности за счет развертывания циклов

## Повышение производительности за счет векторизации циклов

## Заключение

## Особые благодарности
