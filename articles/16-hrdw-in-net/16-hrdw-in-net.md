# Встроенные функции аппаратного обеспечения в .NET Core
автор: *Tanner Gooding*  
перевод: *Андрей Гончаров*  
[Орегинал статьи](https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/) 

### Предисловие к переводу
*Мне нравиться наблюдать за развитием платформы .NET, а точнее языка C#. Придя из мира C++, и имеея небольшой опыт разработки на Delphy мне было очень комфортно начать писать программы на C#. В 2006 году этот язык программирования (именно язык) мне показался более лаконичным, и более перспективным чем Java. Затем появился F#. Он стал эксперементальной площадки для функциональной парадигмы в мире .NET. Результатом эксперементов стал следующий этап в эволюции C# - расширение его возможностей, за счет введения анонимных функции, лямбда выражений, и, в конечном итоге, LINQ. Такое расширение языка сделало C# самым продвинутым, с моей точки зрения, языком общего назначения. Следующий шаг эволюции был связан с поддержкой параллелилизма и асинхронности. Task, вся концепция TPL, развитие LINQ - PLINQ, и, в конце концов, async/await. И вот, в последние два-три года, мы наблюдаем новый этап эволюции платформы .NET и языка C# - движение в сторону обеспечения высокопроизводительных вычислений. Сюда относятся введение Span&lt;T&gt; и Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct и квалификатор in, асинхронынй foreach, IO.Streams. Все эти нововведения направлены на снижение нагрузки на GC и повышения производетельнсоти кода. В этой статье, представлен следующий шаг в этом направлении - предоставления разработчику доступа к функциям аппаратного обеспечения. Я рад, что в разработке платформы .NET и языка C#, в частности, участвую инжинеры с такими широкими и разносторонними взглядами и интересами. Надеюсь увидеть (а может даже приложить свою руку к этому) еще много интересных поворотов на этом пути.*

## Введение
Несколько лет назад, [мы решили что настало время поддержать SIMD код в .NET](https://devblogs.microsoft.com/dotnet/the-jit-finally-proposed-jit-and-simd-are-getting-married/). Мы представили пространство имен `System.Numerics` с типами `Vector2`, `Vector3`,`Vector4` и `Vector<T>`. Эти типы представляют API общего назначения для создания, доступа и оперирования векторных инструкций, когда это возможно. Они, так же, обеспечивают програмную совместимость для тех случаев, где аппаратное обеспечение не поддерживает подходящих инструкций. Это позволило с минимальным рефакторингом векторизовать ряд алгоритмов. Как бы там ни было, общность такого подхода делает его сложным в применении с целью получения полного приемущество от всех доступных, на современном аппаратном обеспечении, векторных инструкций. В дополнении, современное аппаратное обеспечение предосталяет ряд специализированных, не векторны, инструкций, которые могут значительно улучшать производительность. В этой статье, я расскажу как мы справились с этими ограничениями в .NET Core 3.0.

## Что такое встроенные функции аппаратного обеспечения (ВФАО).
В .NET Core 3.0 мы добавили новую фичу под названием *аппаратные встроенные функции*. Эти функции обеспечивают доступ ко многим специфичным инструкциям аппаратного обеспечения, которые не могут быть легко представлены механизмами более общего назначения. Они отличаются от существующих SIMD функций, тем что они не имеют общего назначения (новые ВФАО не являются кросс-платформенными и их архитектура не обеспечивает программной совместимости), вместо этого, они напрямую обеспечивают платформенно и аппартно зависимую функциональность для разработчиков .NET. Существующие SIMD встроенные функции, к примеру, кросс-платформенные, обеспечивают програмную совместимости, и они слегка абстрагированны от лежащего под ними аппаратного обеспечения. Эта абстракция может быть дорогостоящей, к тому же она может препятствовать раскрытию некоторой функциональности (когда, например, функциональность не существует, или сложно эмулирема на всех целевых платформах).

Новые встроенные функции и поддерживаемые типы расположены по пространством имен `System.Runtime.Intrinsics`. Для .NET Core 3.0, в настоящий момент, существует одно пространство имен `System.Runtime.Intrinsics.X86`. Мы работаем над поддержкой ВФАО для другх платформ, таких как `System.Runtime.Intrinsics.Arm`.


## Какие приемущество они дают?

## Векторизация простого алгоритма

## Повышение производительности за счет развертывания циклов

## Повышение производительности за счет векторизации циклов

## Заключение

## Особые благодарности
